#pragma once

#include "../Base.h"

#ifdef NS_PLATFORM_WINDOWS

#include <WinSock2.h>

#endif	// NS_PLATFORM_WINDOWS

namespace ns {


	class NS_API Packet {
		// A bool-like type that cannot be converted to integer or pointer types
		typedef bool (Packet::*BoolType)(std::size_t);

	public:
		Packet();
		~Packet();

		////////////////////////////////////////////////////////////
		/// \brief Append data to the end of the packet
		///
		/// \param data        Pointer to the sequence of bytes to append
		/// \param sizeInBytes Number of bytes to append
		///
		/// \see clear
		///
		////////////////////////////////////////////////////////////
		void append(const void* data, std::size_t sizeInBytes);

		////////////////////////////////////////////////////////////
		/// \brief Clear the packet
		///
		/// After calling Clear, the packet is empty.
		///
		/// \see append
		///
		////////////////////////////////////////////////////////////
		void clear();

		////////////////////////////////////////////////////////////
		/// \brief Get a pointer to the data contained in the packet
		///
		/// Warning: the returned pointer may become invalid after
		/// you append data to the packet, therefore it should never
		/// be stored.
		/// The return pointer is NULL if the packet is empty.
		///
		/// \return Pointer to the data
		///
		/// \see getDataSize
		///
		////////////////////////////////////////////////////////////
		const void* getData() const;

		////////////////////////////////////////////////////////////
		/// \brief Get the size of the data contained in the packet
		///
		/// This function returns the number of bytes pointed to by
		/// what getData returns.
		///
		/// \return Data size, in bytes
		///
		/// \see getData
		///
		////////////////////////////////////////////////////////////
		std::size_t getDataSize() const;

		////////////////////////////////////////////////////////////
		/// \brief Tell if the reading position has reached the
		///        end of the packet
		///
		/// This function is useful to know if there is some data
		/// left to be read, without actually reading it.
		///
		/// \return True if all data was read, false otherwise
		///
		/// \see operator bool
		///
		////////////////////////////////////////////////////////////
		bool endOfPacket() const;

	public:

		////////////////////////////////////////////////////////////
		/// \brief Test the validity of the packet, for reading
		///
		/// This operator allows to test the packet as a boolean
		/// variable, to check if a reading operation was successful.
		///
		/// A packet will be in an invalid state if it has no more
		/// data to read.
		///
		/// This behavior is the same as standard C++ streams.
		///
		/// Usage example:
		/// \code
		/// float x;
		/// packet >> x;
		/// if (packet)
		/// {
		///    // ok, x was extracted successfully
		/// }
		///
		/// // -- or --
		///
		/// float x;
		/// if (packet >> x)
		/// {
		///    // ok, x was extracted successfully
		/// }
		/// \endcode
		///
		/// Don't focus on the return type, it's equivalent to bool but
		/// it disallows unwanted implicit conversions to integer or
		/// pointer types.
		///
		/// \return True if last data extraction from packet was successful
		///
		/// \see endOfPacket
		///
		////////////////////////////////////////////////////////////
		operator BoolType() const;

		////////////////////////////////////////////////////////////
		/// Overload of operator >> to read data from the packet
		///
		////////////////////////////////////////////////////////////
		Packet& operator >>(bool&         data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator >>(Int8&         data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator >>(Uint8&        data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator >>(Int16&        data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator >>(Uint16&       data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator >>(Int32&        data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator >>(Uint32&       data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator >>(Int64&        data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator >>(Uint64&       data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator >>(float&        data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator >>(double&       data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator >>(char*         data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator >>(std::string&  data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator >>(wchar_t*      data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator >>(std::wstring& data);

		////////////////////////////////////////////////////////////
		/// Overload of operator << to write data into the packet
		///
		////////////////////////////////////////////////////////////
		Packet& operator <<(bool                data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator <<(Int8                data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator <<(Uint8               data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator <<(Int16               data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator <<(Uint16              data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator <<(Int32               data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator <<(Uint32              data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator <<(Int64               data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator <<(Uint64              data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator <<(float               data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator <<(double              data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator <<(const char*         data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator <<(const std::string&  data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator <<(const wchar_t*      data);

		////////////////////////////////////////////////////////////
		/// \overload
		////////////////////////////////////////////////////////////
		Packet& operator <<(const std::wstring& data);

	private:

		////////////////////////////////////////////////////////////
		/// Disallow comparisons between packets
		///
		////////////////////////////////////////////////////////////
		bool operator ==(const Packet& right) const;
		bool operator !=(const Packet& right) const;

		////////////////////////////////////////////////////////////
		/// \brief Check if the packet can extract a given number of bytes
		///
		/// This function updates accordingly the state of the packet.
		///
		/// \param size Size to check
		///
		/// \return True if \a size bytes can be read from the packet
		///
		////////////////////////////////////////////////////////////
		bool checkSize(std::size_t size);

	private:
		std::vector<char> m_data;	// the data in packet
		std::size_t       m_readPos; ///< Current reading position in the packet
		std::size_t       m_sendPos; ///< Current send position in the packet (for handling partial sends)
		bool              m_isValid; ///< Reading state of the packet
	};

}
